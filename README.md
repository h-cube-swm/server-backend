# The-Form Backend

이 프로젝트는 설문조사플랫폼 The-Form을 위한 Backend입니다.

## 의사결정과정

### 서버 종류

서버는 다음과 같이 세 종류가 요구된다.

1. 프론트엔드 개발 때 접속할 테스트용 백엔드 - DB는 SQLite / 실시간 업데이트 필요 없음
2. 백엔드 개발을 진행할 백엔드 - DB는 SQLite / 실시간 업데이트 지원해야 함
3. 실제 프로덕션 백엔드 - DB는 외부 실제 DB 사용 / 실시간 업데이트 필요 없음

이때 실시간 업데이트가 가능해야 하는 것은 오직 2번이며, 나머지는 실행 파일을 포함한 모든 구성요소가 전부 dockerized되어도 문제가 없다.

### 환경 변수 분리

현재 모든 환경 변수가 리포지토리 외부에서 `docker-compose`를 실행할 때 공급되고 있다. 이 방법은 다양한 서비스의 환경 변수를 하나의 파일에 모음으로써 관리 지점을 하나로 줄여줄 수 있지만 서비스간 커플링 강도를 증가시킨다. 왜냐하면 적절하게 설정된 `docker-compose`환경이 없다면 아예 서비스를 실행조차 할 수 없기 때문이다. 반면 커플링 강도를 줄이기 위해 환경 변수를 각 서비스 리포지토리 내부에 (git에서 추적되지 않는) `.env`파일 (혹은 `secrets.py`) 등으로 분리하여 저장할 수도 있지만, 리포지토리 외부에서 참조되는 환경 변수들도 있으므로 모든 환경 변수를 프로젝트 안에 포함할 수는 없다. 즉, 여기에는 trade-off가 있다. 그러므로 현재 프로젝트의 진행 상황에 따라 어떤 방식을 택할지를 결정해야한다.

이는 곧 서비스의 캡슐화와 직결된다. 왜냐하면 환경 변수를 분리하는 목적은 서비스의 커플링 강도를 낮추기 위함인데, 그럼에도 서비스를 캡슐화하지 않는다면 이는 목적을 달성하지 못하는 것이기 때문이다. 따라서 환경 변수의 분리를 결정하기 위해서는 좀 더 큰 맥락에서, 서비스 자체를 캡슐화할 것인지를 먼저 살펴보아야 한다.

지금까지는 백엔드와 프론트엔드 개발을 동시에 진행하기 위해 하나의 개발 서버를 사용하여 위 세 가지 목적을 모두 수행하였다. (사실 배포는 하지 않았으므로 프로덕션 서버는 없었다.) 이는 개발 초기에 하루에도 몇 번씩 중요한 프론트/백엔드 변경이 이루어지는 상황에서 서비스를 캡슐화하면 integration에 드는 비용이 너무 컸기 때문이다. 그러나 이제 프론트엔드에서 개발을 하기 위한 최소한의 백엔드 기능, 또한 백엔드에서 개발을 하기 위한 최소한의 프론트엔드 기능이 구현이 완료되었다. 즉, 프론트엔드와 백엔드는 거의 독립적으로 개발을 진행할 수 있으며 따라서 서비스를 캡슐화한다 하더라도 integration에 드는 비용이 크지 않다고 볼 수 있다. 따라서 서비스를 dockerize하여 서버 외 환경에서도 독립적으로 수행될 수 있도록 캡슐화할 필요가 있다.

### 리포지토리에 포함할 환경 변수

다음으로 환경변수를 구체적으로 어떻게 분리할지 고민하자. 현재 `docker-compose`에서 공급되는 환경변수들 중에서 어떤 환경변수가 리포지토리 외부에서 공급되어야 하며 어떤 환경 변수가 리포지토리 내부에서 공급되어야 하는가?

아래 환경 변수들의 포함 기준을 결정하기 위해, 다음과 같이 두 가지 기준을 세우고 환경 변수를 분류하였다.

- **환경 변수가 컨테이너 외부에서 참조되는가?** 예를 들어 데이터베이스 이름이나 비밀번호, reverse proxy를 위한 도메인 네임 등은 컨테이너 외부에서도 참조되는 값이다. 만약 어떤 변수가 외부에서도 참조된다면 그 변수는 리포지토리 내에서 공급되어서는 안 될 것이다.

- **환경 변수에 기본 값을 설정해줄 수 있는가?** 예를 들어 장고 내부적으로 사용되는 시크릿 키 등은 기본 값을 설정해줄 수 있다. 이는 추후 환경 변수 공급에 관해 의사결정을 하기 위한 결정 기준이며 환경 변수를 분리해야하는지의 여부에는 영향을 미치지 않는다.

아래 변수들은 외부에서 참조되지 않고 기본값을 설정해줄 수 있다.

- SECRET_KEY
- DJANGO_SUPERUSER_USERNAME
- DJANGO_SUPERUSER_PASSWORD
- DJANGO_SUPERUSER_EMAIL

아래 변수들은 외부에서 참조되지 않으며 기본값을 설정해줄 수 없다. (MAILGUN_API_KEY등은 물론 메일 서버에서는 사용되겠지만, 아예 서버 자체가 다르므로 환경변수를 어딘가 저장해놓고 공유하는 것 등이 불가능하다. 즉, 환경 변수를 리포지토리 밖에서 공급함으로써 얻는 이득이 없다.)

- MAILGUN_API_KEY
- EMAIL_HOST
- EMAIL_HOST_USER
- EMAIL_HOST_PASSWORD

아래 변수들은 외부에서 참조되며 기본값을 설정해줄 수 있다. (데이터베이스와 관련된 변수들의 경우 기본값을 공급해준다기보다는 값이 공급되지 않을 경우 debug mode로 간주하여 SQLite를 사용하면 된다.)

- POSTGRES_USER_PRODUCTION
- POSTGRES_PASSWORD_PRODUCTION
- POSTGRES_DB_PRODUCTION
- POSTGRES_HOST_PRODUCTION
- DEBUG

다만 위에서 DEBUG 변수는 환경 변수를 설정하는 것이 아니라 아예 Dockerfile 자체를 production과 development로 분리함으로써 환경 변수의 설정을 달성할 것이다.

외부에서 참조되며 기본값을 설정해줄 수 없는 변수는 없다.

### 리포지토리에 환경변수를 포함할 방법

위 항목에서 일부 환경 변수가 리포지토리 내부에 포함되어야 함을 밝혔다. 이때 리포지토리에 환경 변수를 포함하는 방법은 다양하다. `.env` 파일을 만든 후 이를 로드할 수도 있고, 커맨드라인에서 docker container를 실행할 때 직접 환경 변수를 공급해주는 방법도 있다.

이를 결정하기 위해, 앞서 언급한 세 가지 환경 - 프론트엔드 테스트, 백엔드 테스트, 프로덕션 - 이 어떻게 실행될지 생각해보자.

먼저 프로덕션 서버나 프론트엔드 테스트 서버의 경우 `git pull`을 수행한 후 docker build를 통해 도커 컨테이너를 빌드하게 될 것이다.
그러므로 이미지가 매번 새롭게 빌드될 것이다.

백엔드 테스트 서버도 크게 다르지 않다. 다만 백엔드 테스트 서버의 경우 소스코드가 모두 컨테이너에 포함되는 것이 아니라 리포지토리에 마운트된다는 점이 다르다.

또한 프론트엔드 테스트 시에는 로컬에서 띄울 텐데, 이 경우 `docker-compose`나 쉘 스크립트를 이용할 수 있다.
