# The-Form Backend

이 프로젝트는 설문조사플랫폼 The-Form을 위한 Backend입니다.

## 의사결정과정

### 서버 종류

서버는 다음과 같이 세 종류가 요구된다.

1. 프론트엔드 개발 때 접속할 테스트용 백엔드 - DB는 SQLite / 실시간 업데이트 필요 없음
2. 백엔드 개발을 진행할 백엔드 - DB는 SQLite / 실시간 업데이트 지원해야 함
3. 실제 프로덕션 백엔드 - DB는 외부 실제 DB 사용 / 실시간 업데이트 필요 없음

이때 실시간 업데이트(라이브 서버)가 가능해야 하는 것은 오직 2번이며, 나머지는 실행 파일을 포함한 모든 구성요소가 전부 dockerized되어도 문제가 없다.
이에 대해서는 추후 논의할 것이다.

### 환경 변수 분리 여부

현재 모든 환경 변수가 리포지토리 외부에서 `docker-compose`를 실행할 때 공급되고 있다. 이 방법은 다양한 서비스의 환경 변수를 하나의 파일에 모음으로써 관리 지점을 하나로 줄여줄 수 있지만 서비스간 커플링 강도를 증가시킨다. 왜냐하면 적절하게 설정된 `docker-compose`환경이 없다면 아예 서비스를 실행조차 할 수 없기 때문이다. 반면 커플링 강도를 줄이기 위해 환경 변수를 각 서비스 리포지토리 내부에 (git에서 추적되지 않는) `.env`파일 (혹은 `secrets.py`) 등으로 분리하여 저장할 수도 있지만, 리포지토리 외부에서 참조되는 환경 변수들도 있으므로 모든 환경 변수를 프로젝트 안에 포함할 수는 없다. 즉, 여기에는 trade-off가 있다. 그러므로 현재 프로젝트의 진행 상황에 따라 어떤 방식을 택할지를 결정해야한다.

이는 곧 서비스의 캡슐화와 직결된다. 왜냐하면 환경 변수를 분리하는 목적은 서비스의 커플링 강도를 낮추기 위함인데, 그럼에도 서비스를 캡슐화하지 않는다면 이는 목적을 달성하지 못하는 것이기 때문이다. 따라서 환경 변수의 분리를 결정하기 위해서는 좀 더 큰 맥락에서, 서비스 자체를 캡슐화할 것인지를 먼저 살펴보아야 한다.

지금까지는 백엔드와 프론트엔드 개발을 동시에 진행하기 위해 하나의 개발 서버를 사용하여 위 세 가지 목적을 모두 수행하였다. (사실 배포는 하지 않았으므로 프로덕션 서버는 없었다.) 이는 개발 초기에 하루에도 몇 번씩 중요한 프론트/백엔드 변경이 이루어지는 상황에서 서비스를 캡슐화하면 integration에 드는 비용이 너무 컸기 때문이다. 그러나 이제 프론트엔드에서 개발을 하기 위한 최소한의 백엔드 기능, 또한 백엔드에서 개발을 하기 위한 최소한의 프론트엔드 기능이 구현이 완료되었다. 즉, 프론트엔드와 백엔드는 거의 독립적으로 개발을 진행할 수 있으며 따라서 서비스를 캡슐화한다 하더라도 integration에 드는 비용이 크지 않다고 볼 수 있다. 따라서 서비스를 dockerize하여 서버 외 환경에서도 독립적으로 수행될 수 있도록 캡슐화할 필요가 있다.

### 리포지토리에 포함할 환경 변수

다음으로 환경변수를 구체적으로 어떻게 분리할지 고민하자. 현재 `docker-compose`에서 공급되는 환경변수들 중에서 어떤 환경변수가 리포지토리 외부에서 공급되어야 하며 어떤 환경 변수가 리포지토리 내부에서 공급되어야 하는가?

아래 환경 변수들의 포함 기준을 결정하기 위해, 다음과 같이 두 가지 기준을 세우고 환경 변수를 분류하였다.

- **환경 변수가 컨테이너 외부에서 참조되는가?** 예를 들어 데이터베이스 이름이나 비밀번호, reverse proxy를 위한 도메인 네임 등은 컨테이너 외부에서도 참조되는 값이다. 만약 어떤 변수가 외부에서도 참조된다면 그 변수는 리포지토리 내에서 공급되어서는 안 될 것이다.

- **환경 변수에 기본 값을 설정해줄 수 있는가?** 예를 들어 장고 내부적으로 사용되는 시크릿 키 등은 기본 값을 설정해줄 수 있다. 이는 추후 환경 변수 공급에 관해 의사결정을 하기 위한 결정 기준이며 환경 변수를 분리해야하는지의 여부에는 영향을 미치지 않는다.

아래 변수들은 외부에서 참조되지 않고 기본값을 설정해줄 수 있다.

- SECRET_KEY
- DJANGO_SUPERUSER_USERNAME
- DJANGO_SUPERUSER_PASSWORD
- DJANGO_SUPERUSER_EMAIL

아래 변수들은 외부에서 참조되지 않으며 기본값을 설정해줄 수 없다. (MAILGUN_API_KEY등은 물론 메일 서버에서는 사용되겠지만, 아예 서버 자체가 다르므로 환경변수를 어딘가 저장해놓고 공유하는 것 등이 불가능하다. 즉, 환경 변수를 리포지토리 밖에서 공급함으로써 얻는 이득이 없다.)

- MAILGUN_API_KEY
- EMAIL_HOST
- EMAIL_HOST_USER
- EMAIL_HOST_PASSWORD

아래 변수들은 외부에서 참조되며 기본값을 설정해줄 수 있다. 데이터베이스와 관련된 변수들의 경우 기본값을 공급해준다기보다는 값이 공급되지 않을 경우 debug mode로 간주하여 SQLite를 사용하면 된다. 디버그 변수의 경우 보안을 위하여 DEBUG=True로 기본값을 준다.

- POSTGRES_USER_PRODUCTION
- POSTGRES_PASSWORD_PRODUCTION
- POSTGRES_DB_PRODUCTION
- POSTGRES_HOST_PRODUCTION
- DEBUG

외부에서 참조되며 기본값을 설정해줄 수 없는 변수는 없다.

### 리포지토리에 환경변수를 포함할 방법

위 항목에서 일부 환경 변수가 리포지토리 내부에 포함되어야 함을 밝혔다. 이때 리포지토리에 환경 변수를 포함하는 방법은 다양하다. `.env` 파일을 만든 후 이를 로드할 수도 있고, 커맨드라인에서 docker container를 실행할 때 직접 환경 변수를 공급해주는 방법도 있다.

이를 결정하기 위해, 앞서 언급한 세 가지 환경 - 프론트엔드 테스트, 백엔드 테스트, 프로덕션 - 이 어떻게 실행될지 생각해보자.

먼저 프로덕션 서버나 프론트엔드 테스트 서버의 경우 `git pull`을 수행한 후 docker build를 통해 도커 컨테이너를 빌드하게 될 것이다.
그러므로 이미지가 매번 새롭게 빌드될 것이다. 소스코드는 도커 이미지에 포함될 수도 있고, 아니면 마운트할 수도 있다. 어떤 방법이 적합한가?

- 도커 이미지에 모든 소스코드를 포함할 경우

  - 나중에 쿠버네티스 등을 사용할 경우, 이미지만 배포할 때 편리하다.
  - 서버를 수평적으로 확장해도 서로 독립적이므로 아무런 문제가 발생하지 않는다.
  - SQLite DB 등 임시 파일을 마음대로 생성해도 되는 장점이 있다.
  - 보안을 고려했을 때에도 불필요한 내용이 제외되므로 소스를 포함하는 편이 안전하다.

- 도커 이미지에는 환경만 포함하고, 소스코드는 호스트에 있는 것을 마운트하여 사용하는 경우
  - 업데이트 시 git pull 만 수행하면 되고 별다른 빌드가 불필요하여 업데이트가 매우 편리하다.
  - 결정적으로, 도커에서 작업하는 경우와 다르게 라이브 서버를 사용할 수 있다.

두 안 모두 장점이 있다. 그러나 도커 이미지에 모든 소스코드를 포함하는 경우가 장점이 더 많으므로 그렇게 하되, 개발할 때에는 `/app`디렉토리 자체를 호스트에 마운트하여 라이브 서버를 사용할 수 있도록 하자.

또한 프론트엔드 테스트 시에는 로컬에서 도커를 띄울 텐데, 이 경우 `docker-compose`나 쉘 스크립트를 이용할 수 있다. 그런데 가만히 생각해보면 어차피 docker-compose를 사용한다고 하더라도 환경변수 설정을 비롯하여 설정할 것이 꽤 있고, 따라서 docker-compose를 띄우기 위해 쉘 스크립트가 요구된다. 그러므로 그냥 쉘 스크립트를 바로 사용하기로 하자.

### 업데이트된 형태

위 의사결정 과정에 따라 프로젝트 구조를 다음과 같이 업데이트하였다.

- 환경변수는 리포지토리 내의 `.env`파일에 저장되며 이는 git으로 추적되지 않는다.
- `python-decouple`라이브러리를 사용하여 `.env`변수를 읽어 환경 변수를 로드한다.
- 모든 소스 코드는 도커 컨테이너 내부에 포함된다. 단, 개발을 위해 실시간 수정이 필요할 경우 `-v $(pwd):/app` 옵션을 통해 호스트 디렉토리에 마운트하여 작업이 가능하다.
